using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace cfGodotEngine.Binding;

[Generator(LanguageNames.CSharp)]
public class PropertyBindingGenerator : IIncrementalGenerator
{
    private const string AttrMeta = "cfGodotEngine.Binding.PropertyBindingAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var matched = context.SyntaxProvider.ForAttributeWithMetadataName(
            AttrMeta,
            static (node, _) => node is VariableDeclaratorSyntax,
            static (ctx, _) =>
            {
                var field = (IFieldSymbol)ctx.TargetSymbol;
                var attribute = field.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == AttrMeta);
                return (field, attribute);
            });

        var grouped = matched.Collect();

        context.RegisterSourceOutput(grouped, (spc, fields) =>
        {
            if (fields.IsDefaultOrEmpty) return;

            foreach (var group in fields.GroupBy(f => f.field.ContainingType, SymbolEqualityComparer.Default))
            {
                var type = group.Key as INamedTypeSymbol;
                
                var ns = type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToDisplayString();
                var className = type.Name;
                var typeMods = GetTypeModifiers(type);

                var sb = new StringBuilder();
                GenerateClassHeader(sb);
                sb.AppendLine("     private readonly global::cfEngine.DataStructure.PropertyMap bindingMap = new();");
                sb.AppendLine("     public global::cfEngine.DataStructure.IPropertyMap GetBindings => bindingMap;");

                foreach (var (field, attribute) in group)
                {
                    var fieldName = field.Name;                  
                    var typeName = field.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var propName = ToPascal(fieldName);         
                    var backing = fieldName.StartsWith("_") ? fieldName : "_" + fieldName;

                    sb.AppendLine($"     public {typeName} {propName}");
                    sb.AppendLine("     {");
                    sb.AppendLine($"         get => {backing};");
                    sb.AppendLine("         set");
                    sb.AppendLine("         {");
                    sb.AppendLine($"             var __old = {backing};");
                    sb.AppendLine($"             {backing} = value;");
                    sb.AppendLine($"             bindingMap.Set(BindingKey.{propName}, value);");
                    sb.AppendLine("         }");
                    sb.AppendLine("     }");
                    sb.AppendLine();
                }

                sb.AppendLine("}");
                
                spc.AddSource($"{className}.Binding.generated.cs", sb.ToString());

                sb.Clear();
                GenerateClassHeader(sb);
                sb.Append(
                    @"    public static class BindingKey
    {
"
                    );
                foreach (var (field, attribute) in group)
                {
                    var propName = ToPascal(field.Name);
                    sb.AppendLine($"         public const string {propName} = nameof({propName});");
                }

                sb.AppendLine();
                sb.AppendLine("         internal static System.Collections.Generic.List<string> keys = new();");
                sb.AppendLine();
                sb.AppendLine("         [System.Runtime.CompilerServices.ModuleInitializer]");
                sb.AppendLine("         public static void Init()");
                sb.AppendLine("         {");
                foreach (var (field, _) in group)
                {
                    var propName = ToPascal(field.Name);
                    sb.AppendLine($"            keys.Add({propName});");
                }
                sb.AppendLine("         }");
                
                
                sb.AppendLine("    }");
                
                sb.AppendLine("     public static System.Collections.Generic.IReadOnlyList<string> GetBindingKeys() => BindingKey.keys;");
                
                sb.AppendLine("}");
                
                spc.AddSource($"{className}.BindingKey.generated.cs", sb.ToString());

                void GenerateClassHeader(StringBuilder sb)
                {
                    sb.AppendLine("// <auto-generated />");
                    sb.Append("namespace ").Append(ns).Append(";\n\n");
                    sb.Append(typeMods).Append(' ').Append(className).Append(" : global::cfGodotEngine.Binding.IBindingSource").AppendLine().AppendLine("{");
                }
            }
        });
    }

    private static string GetTypeModifiers(INamedTypeSymbol t) =>
        t.TypeKind == TypeKind.Struct ? "public partial struct" : "public partial class";

    private static string ToPascal(string name)
    {
        var core = name.StartsWith("_") ? name.Substring(1) : name;
        return core.Length == 0 ? core : char.ToUpper(core[0]) + core.Substring(1);
    }
}
