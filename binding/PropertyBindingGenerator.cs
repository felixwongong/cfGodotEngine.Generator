using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace cfGodotEngine.Binding;

[Generator(LanguageNames.CSharp)]
public class PropertyBindingGenerator : IIncrementalGenerator
{
    private const string AttrMeta = "cfGodotEngine.Binding.PropertyBindingAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var matched = context.SyntaxProvider.ForAttributeWithMetadataName(
            AttrMeta,
            static (node, _) => node is VariableDeclaratorSyntax, // <- FIELDS
            static (ctx, _) =>
            {
                var field = (IFieldSymbol)ctx.TargetSymbol;
                var attr = field.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == AttrMeta);
                // try capture initializer text
                var init = (ctx.TargetNode as VariableDeclaratorSyntax)?.Initializer?.Value?.ToString();
                return (field, attr, init);
            });

        var grouped = matched.Collect();

        context.RegisterSourceOutput(grouped, (spc, fields) =>
        {
            if (fields.IsDefaultOrEmpty) return;

            foreach (var group in fields.GroupBy(f => f.field.ContainingType, SymbolEqualityComparer.Default))
            {
                var type = group.Key;
                var ns = type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToDisplayString();
                var className = type.Name;
                var typeMods = GetTypeModifiers((INamedTypeSymbol)type);

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated />");
                if (ns is not null) sb.Append("namespace ").Append(ns).Append(";\n\n");
                sb.Append(typeMods).Append(' ').Append(className).AppendLine().AppendLine("{");

                sb.AppendLine("\t[Godot.Signal] public delegate void TestSignalEventHandler();");

                foreach (var (field, _, initText) in group)
                {
                    var fieldName = field.Name;                  // e.g., _health
                    var typeName = field.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var propName = ToPascal(fieldName);          // Health
                    var backing = fieldName.StartsWith("_") ? fieldName : "_" + fieldName; // keep original
                    var init = initText ?? "default!";

                    // Emit backing (with initializer once; safe if user wrote it already?):
                    // To avoid double-definition, only emit property; rely on user's field.
                    // If you want to re-emit backing, ensure you don't duplicate symbols.
                    sb.AppendLine($"    public {typeName} {propName}");
                    sb.AppendLine("    {");
                    sb.AppendLine($"        get => {backing};");
                    sb.AppendLine("        set");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            if (System.Collections.Generic.EqualityComparer<{typeName}>.Default.Equals({backing}, value)) return;");
                    sb.AppendLine($"            var __old = {backing};");
                    sb.AppendLine($"            {backing} = value;");
                    // sb.AppendLine($"            OnPropertyChanged(nameof({propName}));");
                    // sb.AppendLine($"            On{propName}Changed(__old, value);");
                    sb.AppendLine("        }");
                    sb.AppendLine("    }");
                    // sb.AppendLine($"    partial void On{propName}Changed({typeName} oldValue, {typeName} newValue);");
                    sb.AppendLine();
                }

                sb.AppendLine("}");
                
                spc.AddSource($"{className}.PropertyBinding.generated.cs", sb.ToString());
            }
        });
    }

    private static string GetTypeModifiers(INamedTypeSymbol t) =>
        t.TypeKind == TypeKind.Struct ? "public partial struct" : "public partial class";

    private static string ToPascal(string name)
    {
        var core = name.StartsWith("_") ? name.Substring(1) : name;
        return core.Length == 0 ? core : char.ToUpper(core[0]) + core.Substring(1);
    }
}
